#
# Author: yo1000
# LICENSE: CC BY 4.0
#

ほんとの初学者向け
Javascript から入るプログラミング入門

ここまでのまとめ


# かんたんな確認方法
これが基本。
ブラウザ等でかんたんに変数の状態を確認できるので、
最初に覚えておこう。

```
let name = 'うごめくん'

// ブラウザを「開発者モード」にすると、
// 「コンソール」タブに、
// 「うごめくん」と表示される
console.log(name)
```


# 変数
処理の途中で、値を、後で使えるように、残しておくもの。

下ごしらえした食材を、ボウルに移して、後からサッと調理できるように取り置いておくようなイメージ。
このボウルにあたるのが変数で、変数には、肉の入っているボウル、野菜の入っているボウル、
といった具合に、入っているものに応じた名前をつける。

変数の作り方（名前の付けかた）には、何種類かやり方がある。


## var
variable (変数) の略。

近年では、これを使うのは **推奨されない。**

以下のように使う。

```
var name = 'うごめくん'
```


## let
英語の Let と同等。
英語における数学で、`Let 2x equal y.` (2x は y と等しいとする。)
といった使いかたをされるのから来ている模様

近年では、`var` ではなく、`let` を使用することが推奨されている。
理由としては、
var はスコープを無視するのに対して、
let はスコープを加味するため。
*スコープについては、後述。*

以下のように使う。

```
let name = 'うごめくん'
```


## const
constant (定数) の略。

近年では、使用可能な箇所では、`let` よりも、優先的に使用することが推奨されている。
定数と言うだけあって、一度値が代入されると、再代入ができない。
再代入しようとすると、ブラウザがエラーを検出して、スクリプトの実行が中止される。

なぜこのように、一見不便に見えるものの使用が、最も推奨されているのかというと、
理由としては、例を挙げるとわかりやすい。

再代入を許している (`let` を使う) 場合

```
let name = 'うごめくん'
console.log(name) // name にはうごめくんの「名前」が入っている

name = 5
console.log(name * 2) // name が計算に使われている

name = '2018年2月17日'
console.log(name) // name に日付が入っている

// name とはいったい何だったのか
```

再代入を許さない (`const` を使う) 場合

```
const name = 'うごめくん'
console.log(name) // name にはうごめくんの「名前」が入っている

const value = 5
console.log(value * 2) // value (値) が計算に使われている

const today = '2018年2月17日'
console.log(today) // today に今日の日付が入っている

// それぞれ目的に応じた、名前の付いた定数が使われる
// 再代入が許されないため、当初の目的からは、逸脱するような、
// 意図されていなかった値が、再代入される心配がない
```

今回の例は、さすがに極端ではあるものの、
Javascript では、型の曖昧さも相まって、(*曖昧さについては後述*)
このような、当初の変数の目的に反した、再代入というのが非常に発生しやすい。

そのため、そもそも再代入ができず、その場その場で
適切な名前をつけなければ使うことのできない、`const` を優先的に使うべし、
というのが、近年の推奨傾向となっている。


# 制御構文 (if, while, for)
多くのプログラミング言語には、制御構文というものが用意されている。
制御構文とは、主に、「分岐」、「反復」(繰り返し) を制御するための構文 (書き方) のこと。


## 分岐
`if` を使うと、「分岐」を制御できる。
このような制御構文は、「if 文」と呼ばれる。

以下のように使う。

```
const name = 'しのぶ'
const male = checkMale() // 男の子なら true、女の子なら false
let suffix

if (male) {
    suffix = 'くん'
} else {
    suffix = 'ちゃん'
}

// 男の子なら「しのぶくん」、
// 女の子なら「しのぶちゃん」と表示される
console.log(name + suffix)
```


## 反復 (繰り返し)
`while` を使うと、指定した条件を満たしている間中、
`for` を使うと、指定した値の範囲の間中、繰り返し処理を実行します。
(`for` は、`while` のように、指定した条件を満たしている間中の繰り返しといった使い方もできます)

`while` は以下のように使う。

```
let value = 1000
let count = 0

// 7 で何回割れるかを求める
while (value >= 7) {
    value /= 7
    count++
}

console.log(’1000 は、7で、’ + count + '回割れる')
```

`for` は以下のように使う。

```
const bigs = ['大', '大', '大', '犬', '大']
let index = -1

// 「大」に紛れた「犬」を探す
for (let i = 0; i < bigs.length; i++) {
    if (bigs[i] === '犬') {
        index = i
        break
    }
}

console.log('bigs の' + index + '番目に犬が見つかった')
```


# 型 (基本型とクラス)
Javascript には基本型が4つの基本型と、
たくさんのクラスがある。


## number
数値を表す基本型。
number 同士は、計算することができる。
number 同士であれば、1 + 1 の結果が 2 になる。


## string
文字を表す基本型。
string 同士は、結合することができる。
string 同士であれば、'1' + '1' の結果が '11' になる。
string と、他の方を足し算した場合も、文字の結合になる。


## boolean
真偽 (true/false) を表す基本型。
true と、false の2種類しか表現できない。


## object
先の紹介した、3つの基本型以外の全てが、これに該当する。
クラスはすべて object の仲間である。

*クラスについては後述。*

 
# Javascript のあいまいさ
Javascript では、一部の値の扱いが非常に曖昧になる場合がある。
上手に利用すれば便利になるが、下手に扱うと意図しない動きを誘発したりする。

曖昧になりやすい値の例は以下。

- "undefined" (なにも代入されていない変数の初期値)
- null
- 0 (数値の0)
- '0' (文字の0)
- '' (0文字分の文字)
- false

これらには、曖昧に同じものとみなされる組み合わせが、数多く存在する。

```
let undefValue      // undefine
let nullValue       = null
let zeroValue       = 0
let zeroStringValue = '0'
let emptyValue      = ''
let falseValue      = false
let oneValue        = 1
let oneStringValue  = '1'

// いずれも true (等しいと評価される)
console.log(undefValue  == nullValue)       // undefine と null
console.log(zeroValue   == zeroStringValue) // 0  と ’0’
console.log(zeroValue   == emptyValue)      // 0  と ''
console.log(zeroValue   == falseValue)      // 0  と false
console.log(emptyValue  == falseValue)      // '' と false
console.log(oneValue    == oneStringValue)  // 1  と '1'
```

非常に紛らわしく、バグを抱えやすいポイントでもある。
これらの曖昧さを厳格化することもできる。

比較を厳格化するには、`==` ではなく、`===` を使用する。 
すると、先の例とは一転、すべて false (すべて異なる) という評価に変化する。

```
let undefValue      // undefine
let nullValue       = null
let zeroValue       = 0
let zeroStringValue = '0'
let emptyValue      = ''
let falseValue      = false
let oneValue        = 1
let oneStringValue  = '1'

// いずれも false (異なると評価される)
console.log(undefValue  === nullValue)       // undefine と null
console.log(zeroValue   === zeroStringValue) // 0  と ’0’
console.log(zeroValue   === emptyValue)      // 0  と ''
console.log(zeroValue   === falseValue)      // 0  と false
console.log(emptyValue  === falseValue)      // '' と false
console.log(oneValue    === oneStringValue)  // 1  と '1'
```

このように、変数同士や、変数と値が等しいかどうかを確認したい場合は、
`==` は避け、`===` を積極的に使うようにすることで、ミスを減らすことができる。

また、この曖昧な評価を受ける特徴を利用して、
if 文の条件を簡単に書くこともできたりする。

```
let x = 20
let y = 4
let z = 0

// Javascript において、
// 0 でない数値は true と曖昧に同じとみなされるため、
// この条件の中には入る
if (y) {
    console.log(x / y)
}

// Javascript において、
// 0 は false と曖昧に同じとみなされるため、
// この条件の中には入らない
if (z) {
    console.log(x / z) // 0で割ると無限になるため、エラーになる
}
```

このように便利に使うこともできるので、
曖昧な評価については、その特徴を十分に理解した上で利用しよう。


# 関数 (function)
似たような一連の手続きを、まとめて意味のある名前を与えたり、
繰り返し何度も書いたりしなくて済むように、使いまわせるようにするもの。

色々な書き方ができるが、もっとも基本的な書き方は以下の通り。

```
function 関数名(引数1, 引数2, ..) {
    何らかの処理A
    何らかの処理B
    ..
    
    return 戻り値
}
```


## 関数名
function の名前。
この名前を使って function を呼び出すことができるようになる。


## 引数
function に与えるパラメーター。
引数には、何のパラメーターかが分かるような名前をつける。

イメージとしては、
`三角形の面積 = 底辺 x 高さ / 2` のような公式に与える、
`底辺` や、`高さ` のようなものと同じだと考えて良い。


## 戻り値
function の実行結果。
function は、その実行結果を呼び出し元に返すことができる。

イメージとしては、
`三角形の面積 = 底辺 x 高さ / 2` のような公式の計算結果にあたる、
`三角形の面積` のようなものと同じだと考えて良い。


## 用例
function を使う場合と使わない場合で、以下のような違いがある。
階乗を算出する場面を例に取る。

function を使用せず、階乗を求めたい場合。

```
let value = 10
let answer = 1
let work = value
while (work > 1) {
    answer *= work
    work--
}

console.log(value + ' の階乗は、' + answer + ' です')

value = 8
answer = 1
work = value
while (work > 1) {
    answer *= work
    work--
}

console.log(value + ' の階乗は、' + answer + ' です')
```

function を使用して、階乗を求めたい場合。

```
function factorial(value) {
    let answer = 1
    let work = value
    while (work > 1) {
        answer *= work
        work--
    }
    return answer
}

let value = 10
console.log(value + ' の階乗は、' + factorial(value) + ' です')

value = 8
console.log(value + ' の階乗は、' + factorial(value) + ' です')
```

このように function にまとめておくことで、
同じような計算処理を何度も書かなくて良くなり、
同じ処理をおこないたい場合に、コピーするミスが減ったり、
関数名から、何をしたいのかというのが理解しやすくなったりする。


# スコープ (Namespace: 名前空間)
名前空間という呼ばれ方もあるように、その名前が通じる範囲のことをスコープという。


## ブロックスコープ
一般に、スコープは { } で囲まれた範囲であることが多い。
また、{ } で囲まれた範囲のことをブロックと呼ぶ。

なお、一般的なプログラミング言語では、このブロック ( { } ) をスコープとする、
ブロックスコープが採用されることが多いが、
何をスコープとするかはプログラミング言語によって異なり、
Javascript では、近年までブロックスコープが存在していなかった点に注意。

まずは、スコープがどのように作用するのか、例を見てみる。

```
let a = 1
console.log(a + b + c) // まだ b, c は作成されていないので「エラー」 

if (条件X) {
    let b = 2
    console.log(a + b + c) // まだ c は作成されていないので「エラー」 
    
    if (条件Y) {
        let c = 3
        console.log(a + b + c) // 問題なく「6」と表示される 
    }
    
    if (条件Z) {
        let c = 4 // 本来なら同名の変数は作れないがスコープが異なれば作れる
        console.log(a + b + c) // 問題なく「7」と表示される 
    }
    
    console.log(a + b + c) // c はスコープが異なるので「エラー」 
}

console.log(a + b + c) // b, c はスコープが異なるので「エラー」
```

このように、
スコープの外側の名前は参照でき、
スコープの内側の名前は参照できないという特徴がある。

また、
スコープが異なれば、本来二重に名付けることのできない、
同名の変数を作成することもできるようになる。

スコープがないと何が困るのか、というと、

1つ目は、名前の重複問題。
プログラムの最初から最後まで、同じ名前を全く付けられないということになり、
イイカンジの名前はすぐに使えなくなり、
キラキラネームや、意味の分からない名前をつけざるを得なくなってしまう。

2つ目は、考えるべき範囲が広がってしまう問題。
if の中でだけ、while の中でだけ、function の中でだけ考えておけば良いような、
一時的な変数の状態を、それらが使い終わっても、ずっと頭の何処かに意識しておかないと、
何か問題が出かないだろうかという心配が、尽きなくなってしまう。

3つ目は、コンピューターが、その変数をいつまで覚えておけばいいのか、わからなくなる問題。
スコープがあることで、スコープの範囲外に達した時点で、
コンピューターは、もうその変数が必要ないことを理解する。
これにより、無駄なメモリをいつまでも残しておかなくて良いという利点があるが、
スコープがなければ、コンピューターは、いつまでも無駄なメモリを抱え続けなければならなくなる。


## ファンクションスコープ (スコープに関する落とし穴 1)
冒頭で、以下のように紹介したとおり、
Javascript にはスコープに関する罠がある。

> なお、一般的なプログラミング言語では、このブロック ( { } ) をスコープとする、
> ブロックスコープが採用されることが多いが、
> 何をスコープとするかはプログラミング言語によって異なり、
> Javascript では、近年までブロックスコープが存在していなかった点に注意。

Javascript では、近年 (let, const キーワードが使えるようになる) まで、
そもそも、ブロックスコープというものが存在していなかった。
存在していたのは、ファンクションスコープというもので、
関数の内側と外側でだけ、スコープが異なる、というルールのみが存在していた。
とはいえ、let, const を使っている限りにおいては、これは発生しないので安心して良い。

ただし、変数の説明で出てきた、現在では推奨されていない `var` を使って、
変数を作成した場合、このファンクションスコープというものが使用されてしまう。
ファンクションスコープの世界では、if, while, for などの内側外側には、
名前空間の違いが現れず、うっかり同名の名前を使ったりすると、
以前設定した内容が、そこに残ってしまっていたりする。

これが、人間の脳の一時記憶を非常に消耗させ、混乱をきたし、
バグの温床となりやすい。


## グローバルスコープ (スコープに関する落とし穴 2)
Javascript でのスコープの種類には、ブロックスコープ、ファンクションスコープ以外にも、
グローバルスコープというものもある。

グローバルという名前がついているだけあって、
このスコープで作成された、変数名や関数名は、
実行されている Javascript 内の、どこからでも参照可能な名前となる。

スコープが使えない場合の問題が、すべて現れることになるので、
使用する場合は注意が必要だが、どこからでも呼び出せるという特徴もあるため、
ほんとうに様々な箇所で使わなければならない場合には、よく考えた上で使ってみることもアリではある。

グローバルスコープの変数や、関数を作るには、以下どちらかの方法をとる。

1. script タグの直下に変数や関数を宣言する

```
<script>
var globalValue1 = 1
globalValue2 = 2

function globalFunc() { .. }
</script>
```

2. var, let, const を付けずに変数を作る

```
function globalFunc() {
    glovalValue3 = 3
}
```

実は、var, let, const を付けなくても、変数自体は作れてしまう。
この場合、変数はグローバルスコープに置かれて、
変数が作成されたあとは、いずれのスコープからでも参照可能な変数となる。

ただし、このような使いかたは通常、意図的にやることはなく、
そのような使いかたの多くは、var や let のつけ忘れ、
つまりはバグである。


## スコープについてのまとめ
いろいろなスコープが出てきたが、結局どうするのが良いかというと、

`let`, `const` を使って、ブロックスコープで、
名前を管理するのが良い。

グローバルスコープを使いたくなったら、
プロジェクトを一緒にやっているメンバーなどに一度相談しておくと、
怒られが少なくて良い。


# クラス
クラスは、複数の変数をグルーピングして意味を持つカタマリにしたり、
意味を持つカタマリに関連する操作を集めて、扱いやすくしたもの。

クラスを使う場合と、使わない場合を考えてみる。

三角形の面積を求める例の場合、クラスを使用しないと、
それぞれ「底辺」、「高さ」、といった変数が用意されていはるが、
これが「三角形に使われるために」用意されたのかどうかは、
実際に計算に使われるまでわからない。

```
let bottom = 10
let height = 8
console.log('三角形の面積は' + (bottom * height / 2) + 'です')
```

ところが、意味のあるまとまり、クラスを使用すると、
「底辺」や、「高さ」が三角形のために用意されたものであると、
自然と読み取ることができるようになる。

また、Triangle クラスの中では、
Triangle クラス内で管理される変数のことだけを考えれば良いので、
人間の頭で同時に考えなければならないことを、限定的にしてくれる。
(莫大な量の変数の状態を、頭のなかで同時に記憶しておく必要がなくなる。)

```
class Triangle {
    constructor(bottom, height) {
        this.bottom = bottom
        this.height = height
    }
    
    calcArea() {
        returm this.bottom * this.height / 2
    }
}

console.log('三角形の面積は' + (new Triangle(10, 8).getArea()) + 'です')
```
